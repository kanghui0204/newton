"""
Newton 知识文档 17：Control（控制输入）与 Soft Contact（软接触）
================================================================

【本文件目的】
解释两个在示例中经常出现但没有详细展开的概念：
  1. Control —— 你给仿真系统下的"命令"
  2. Soft Contact / soft_contact_margin —— 粒子与碰撞体之间的柔性接触

【源码位置】
  Control 类:           newton/_src/sim/control.py（全文件只有 93 行）
  软接触核函数:          newton/_src/geometry/kernels.py → create_soft_contacts()
  碰撞管线（margin传入）: newton/_src/sim/collide.py → CollisionPipeline


================================================================================
一、Control（控制输入）
================================================================================

--------------------------------------------------------------------------------
1.1 Control 是什么？
--------------------------------------------------------------------------------

Control 是你给仿真系统发的"命令"，告诉求解器：
  "在这个时间步，我想让关节施加多大的力 / 转到哪个角度"

打个比方：
  - State = 机器人当前的姿态（胳膊在哪、腿在哪）
  - Control = 你发给机器人的指令（"左肘转到 90°"、"右膝施加 10N·m 力矩"）
  - Solver = 机器人的"大脑"，根据当前姿态 + 你的指令，算出下一刻的姿态

如果你不给任何指令（control 全为 0），物体就只受重力和碰撞力影响（自由运动）。

--------------------------------------------------------------------------------
1.2 Control 的所有属性
--------------------------------------------------------------------------------

源码位置: newton/_src/sim/control.py 第 21-93 行

┌────────────────────────┬──────────────────────┬─────────────────────────────────────┐
│ 属性                    │ 形状 / 类型           │ 含义                                 │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ joint_f                 │ float[joint_dof_count]│ 直接给关节施加的力/力矩               │
│                         │                      │ 比如：给电机施加 10N·m 扭矩           │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ joint_target_pos        │ float[joint_dof_count]│ 关节目标位置（角度）                  │
│                         │                      │ 配合 PD 控制器使用                    │
│                         │                      │ 比如："肘关节转到 90°"                │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ joint_target_vel        │ float[joint_dof_count]│ 关节目标速度                          │
│                         │                      │ 比如："电机以 1 rad/s 旋转"            │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ tri_activations         │ float[tri_count]      │ 三角形元素的激活力                    │
│                         │                      │ 用于肌肉驱动的布料                    │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ tet_activations         │ float[tet_count]      │ 四面体元素的激活力                    │
│                         │                      │ 用于人工肌肉（软体机器人）              │
├────────────────────────┼──────────────────────┼─────────────────────────────────────┤
│ muscle_activations      │ float[muscle_count]   │ 肌肉激活量（尚未实现）                │
└────────────────────────┴──────────────────────┴─────────────────────────────────────┘

其中 joint_dof_count = 所有关节的自由度总和。
比如 3 个旋转关节(各 1 自由度) = joint_dof_count = 3。

--------------------------------------------------------------------------------
1.3 什么时候 Control 有用 / 没用？
--------------------------------------------------------------------------------

【有用的场景】—— 有关节的机器人

    # 04_robot_cartpole 示例中：给关节施加控制力
    control = model.control()
    control.joint_f.assign([10.0, -5.0])  # 给 2 个关节施加力

    # 强化学习中：神经网络输出 action → 写入 control
    action = policy(observation)              # 神经网络输出
    control.joint_target_pos.assign(action)   # 写入关节目标位置
    solver.step(state_in, state_out, control, contacts, dt)

【没用的场景】—— 没有关节（如 05_diffsim_ball）

    # diffsim_ball 只有一个自由粒子，没有关节
    # control 创建了但全是 None/空的
    self.control = self.model.control()
    # 它出现在这里只是因为 solver.step() 的接口要求传这个参数
    solver.step(state_0, state_1, self.control, contacts, dt)
    #                              ^^^^^^^^^^ 占位，不起作用

--------------------------------------------------------------------------------
1.4 Control 在仿真循环中的位置
--------------------------------------------------------------------------------

    每个时间步：
    ┌──────────────────────────────────────────┐
    │  1. state.clear_forces()                  │
    │  2. 【你在这里设置 control】               │  ← 设置本步的命令
    │     control.joint_target_pos = ...         │
    │  3. collision_pipeline.collide(state)      │
    │  4. solver.step(state_in, state_out,       │  ← 求解器读取 control
    │                 control, contacts, dt)      │
    │  5. swap(state_in, state_out)              │
    └──────────────────────────────────────────┘

    solver.step() 内部会读取 control 中的值：
    - joint_f          → 直接加到关节力上
    - joint_target_pos → 算 PD 弹簧力：f = ke*(target - current) - kd*velocity
    - joint_target_vel → 算阻尼力


================================================================================
二、Soft Contact 与 soft_contact_margin
================================================================================

--------------------------------------------------------------------------------
2.1 Rigid Contact vs Soft Contact
--------------------------------------------------------------------------------

Newton 有两种碰撞接触方式：

【Rigid Contact（硬接触）】
  - 用于刚体之间的碰撞（盒子撞盒子）
  - 计算精确接触点、法线、穿透深度
  - 通过窄相检测（GJK/MPR 算法）
  - ❌ 不可微（"是否穿透"是 0/1 的阶跃函数，导数为 0 或无穷大）
  - 源码: newton/_src/geometry/narrow_phase.py

【Soft Contact（软接触）】
  - 用于粒子与碰撞体之间的接触
  - 用 SDF（有符号距离场）计算距离 d
  - 接触力 f = ke × max(-d, 0) → 连续、可微！
  - ✅ 可微仿真必须用这个
  - 源码: newton/_src/geometry/kernels.py → create_soft_contacts()

在 requires_grad=True（可微仿真）时，Newton 会：
  - 跳过 rigid contact（不可微，不录入 Tape）
  - 只计算 soft contact（可微，能被 tape.backward() 反传）

--------------------------------------------------------------------------------
2.2 soft_contact_margin 是什么？
--------------------------------------------------------------------------------

margin（边距）就是粒子的"感知范围"——在多远的距离内开始检测碰撞。

    soft_contact_margin = 10.0  意思是：
    "粒子周围 10 米以内的所有碰撞体都要检测"

示意图（从粒子的视角看）：

    margin = 0.01（默认值，很小）：
    ┌────────────────────────────────┐
    │            碰撞体              │
    │                                │
    │   ○ ← 粒子                    │
    │   ╰╮ 0.01m 感知范围            │  ← 只在几乎贴着碰撞体时才检测
    │    ╰────╮                      │     适合：普通仿真，省计算量
    └────────────────────────────────┘

    margin = 10.0（diffsim_ball 用的）：
    ┌────────────────────────────────┐
    │            碰撞体              │
    │                                │
    │   ○ ← 粒子                    │
    │   ╰════════════════════╮       │  ← 10 米内都能感知到碰撞体
    │    10m 感知范围          ╰──╮   │     适合：可微仿真，需要远距离梯度
    └────────────────────────────────┘

--------------------------------------------------------------------------------
2.3 为什么 diffsim_ball 要设 margin=10.0 这么大？
--------------------------------------------------------------------------------

因为可微仿真需要在小球还没碰到墙之前就能"感知"到墙的存在。

普通仿真（margin=0.01）：
  小球飞行中 → 距墙 5 米 → 感知不到 → 无梯度信息 → 优化器不知道该往哪调
  小球飞行中 → 距墙 0.01 米 → 刚感知到 → 已经来不及了

可微仿真（margin=10.0）：
  小球飞行中 → 距墙 5 米 → 已经感知到！ → 有梯度信息 → 优化器知道"再偏一点就撞墙了"

关键点：
  - SDF 距离 d 是一个关于粒子位置的连续函数
  - 距墙越近，d 越小 → 力越大 → 梯度越大
  - 如果 margin 太小，大部分轨迹上 d > margin → 梯度为 0 → 优化器"瞎了"

所以 margin 设大 = 让优化器有更多的梯度信号来引导搜索方向。
代价是计算量增大（检测更多粒子-形状对），但 diffsim_ball 只有 1 个粒子，无所谓。

--------------------------------------------------------------------------------
2.4 soft contact 的实际检测逻辑
--------------------------------------------------------------------------------

源码位置: newton/_src/geometry/kernels.py 第 696-835 行
函数: create_soft_contacts()

对于每一对 (粒子, 碰撞体)，并行执行：

    1. 把粒子位置转换到碰撞体的局部坐标系
       x_local = transform_inverse(X_ws) * particle_pos

    2. 根据碰撞体类型计算 SDF 距离 d：
       - SPHERE(球):   d = |x_local| - radius
       - BOX(盒):      d = box_sdf(scale, x_local)
       - CAPSULE(胶囊): d = capsule_sdf(...)
       - MESH(网格):    d = mesh_query_point(...)   ← 查询最近面的距离
       - PLANE(平面):   d = plane_sdf(...)
       - SDF(体积SDF):  d = volume_sample(...)

    3. 判断：d < margin + particle_radius ?
       - 是 → 记录这个接触（存粒子ID、碰撞体ID、法线、接触点）
       - 否 → 跳过

    4. 之后 solver.step() 中会读取这些接触信息，用弹簧力模型算接触力：
       f = ke * max(-d, 0) * normal    ← 距离越近力越大，可微！

--------------------------------------------------------------------------------
2.5 总结对比
--------------------------------------------------------------------------------

┌────────────────────┬──────────────────────┬──────────────────────────┐
│                    │ Rigid Contact         │ Soft Contact              │
├────────────────────┼──────────────────────┼──────────────────────────┤
│ 作用对象            │ 刚体 vs 刚体         │ 粒子 vs 碰撞体            │
│ 检测方法            │ GJK/MPR 精确检测     │ SDF 距离查询               │
│ 接触力模型          │ 约束投影 / 脉冲      │ 弹簧力 f = ke*max(-d,0)   │
│ 可微？              │ ❌ 不可微            │ ✅ 可微                    │
│ margin 作用         │ 膨胀 AABB            │ 粒子感知范围               │
│ 默认 margin         │ 由碰撞体形状决定     │ 0.01 米                   │
│ 适合场景            │ 普通刚体仿真         │ 可微仿真 / 布料粒子碰撞   │
│ 源码                │ narrow_phase.py      │ geometry/kernels.py       │
└────────────────────┴──────────────────────┴──────────────────────────┘
"""
