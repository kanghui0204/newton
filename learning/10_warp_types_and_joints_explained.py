"""
Newton 基础概念详解 10：Warp 核心类型与关节系统
================================================

这是一份面向零基础初学者的详细解释文档。
涵盖：vec3、quat、transform、spatial_vector 四大类型，
以及关节系统、正运动学、State 的数据结构。

================================================================================
一、wp.vec3 — 三维向量（3个浮点数）
================================================================================

vec3 就是三个数字的组合 (x, y, z)，表示三维空间中的量。

【同一个类型，不同的含义（取决于上下文）】

    用作 位置:  wp.vec3(1.0, 2.0, 3.0) → 空间中的一个点 (x=1, y=2, z=3)
    用作 方向:  wp.vec3(1.0, 0.0, 0.0) → "朝右"这个方向（X轴正方向）
    用作 速度:  wp.vec3(5.0, 0.0, 0.0) → 每秒向右移动5米
    用作 力:    wp.vec3(0, 0, -9.81)    → 重力（向下9.81 m/s²）
    用作 尺寸:  wp.vec3(0.5, 0.3, 0.2)  → 盒子的半尺寸

    它们在内存中完全一样，都是3个float。
    "是位置还是方向"取决于你怎么用它。

【Newton 中的坐标系约定】

    默认 Z 轴朝上：
         Z (上)
         │
         │
         │_______ Y (前)
        /
       /
      X (右)

    重力 = wp.vec3(0, 0, -9.81)  → 沿 Z 轴向下
    地面在 Z = 0

================================================================================
二、wp.quat — 四元数（4个浮点数，表示旋转）
================================================================================

四元数用4个数 (x, y, z, w) 表示三维旋转。

【白话理解】

    四元数回答一个问题："物体相对于初始状态，转了多少？"

    quat_identity() = (0, 0, 0, 1)  → "没转，保持原样"
    这就像数学里的1：任何数乘以1还是自己。

【创建四元数的方法】

    方法1：不旋转
        q = wp.quat_identity()

    方法2：绕某个轴转指定角度（最常用）
        q = wp.quat_from_axis_angle(轴, 角度弧度)

        例子：绕Z轴（竖直轴）转90°
        q = wp.quat_from_axis_angle(wp.vec3(0,0,1), π/2)

        想象：你站着原地向左转90° → 你的朝向变了

    方法3：从欧拉角 (roll, pitch, yaw)
        q = wp.quat_rpy(roll, pitch, yaw)
        roll  = 绕X轴转（左右晃头）
        pitch = 绕Y轴转（点头）
        yaw   = 绕Z轴转（摇头说"不"）

【四元数的运算】

    旋转一个向量：
        rotated = wp.quat_rotate(q, vec3)
        → 把 vec3 按照 q 描述的旋转转一下

        例子：箭头朝右 (1,0,0)，绕Z轴转90°后朝前 (0,1,0)
        direction = wp.vec3(1, 0, 0)
        q = wp.quat_from_axis_angle(wp.vec3(0,0,1), π/2)
        result = wp.quat_rotate(q, direction)  # ≈ (0, 1, 0)

【四元数的4个数到底是什么？（可跳过）】

    q = (sin(θ/2)·ax, sin(θ/2)·ay, sin(θ/2)·az, cos(θ/2))
    其中 (ax, ay, az) 是旋转轴，θ 是旋转角度

    不需要手动算！用 quat_from_axis_angle 就行。

================================================================================
三、wp.transform — 位姿（7个浮点数 = vec3 + quat）
================================================================================

transform = 位置(vec3) + 旋转(quat) 的组合。
完整描述一个物体"在哪里"和"朝哪个方向"。

    transform[0:3] = 位置 (x, y, z)
    transform[3:7] = 旋转 (qx, qy, qz, qw)

【类比】

    想象你在房间里放一把椅子：
    - 位置 = 椅子放在哪个角落 → vec3(2, 3, 0)
    - 旋转 = 椅子面向哪个方向 → quat(绕Z轴转了45°)
    - transform = 以上两者的组合

【创建方式】

    # 在 (0,0,5) 位置，不旋转
    xform = wp.transform(p=wp.vec3(0, 0, 5), q=wp.quat_identity())

    # 在 (1,2,0) 位置，绕Z轴转45°
    xform = wp.transform(
        p=wp.vec3(1, 2, 0),
        q=wp.quat_from_axis_angle(wp.vec3(0,0,1), π/4)
    )

【在 Newton 中的用途】

    1. body_q[i] = wp.transform  → 第i个刚体的当前位姿
    2. add_body(xform=...) → 指定刚体的初始位姿
    3. parent_xform / child_xform → 关节的安装位置（详见下面关节部分）
    4. shape_transform → 形状相对于body的偏移

【常用操作】

    取出位置:  pos = wp.transform_get_translation(xform)  → vec3
    取出旋转:  rot = wp.transform_get_rotation(xform)     → quat
    组合变换:  T_ab = wp.transform_multiply(T_a, T_b)    → 先做T_b再做T_a
    变换一个点: world_pt = wp.transform_point(body_xform, local_pt)
    逆变换:    T_inv = wp.transform_inverse(T)

================================================================================
四、wp.spatial_vector — 空间向量（6个浮点数）
================================================================================

把"线性量"(3个float)和"角度量"(3个float)打包在一起。

    spatial_vector = (v₀, v₁, v₂, v₃, v₄, v₅)
                      ├── top ──┤  ├── bottom ─┤
                       线性部分      角度部分

【两种用途】

    用作速度 (body_qd):
        top    = 线速度 (vx, vy, vz)     → 物体在平移多快
        bottom = 角速度 (ωx, ωy, ωz)     → 物体在旋转多快

    用作力 (body_f):
        top    = 力 (fx, fy, fz)          → 推物体的力
        bottom = 力矩 (τx, τy, τz)       → 扭物体的力矩

【为什么速度和力用同一个类型？】

    因为牛顿第二定律:
        新速度 = 旧速度 + (力/质量) × 时间

    等号两边结构相同（都是6维，都是线性+角度的组合），
    所以用同一个类型是自然的。

    类比：距离和速度都用"米"相关的单位，虽然含义不同但格式一样。

【访问方式】

    sv = wp.spatial_vector(1, 2, 3, 4, 5, 6)
    wp.spatial_top(sv)     → wp.vec3(1, 2, 3)  = 线性部分
    wp.spatial_bottom(sv)  → wp.vec3(4, 5, 6)  = 角度部分

    # 也可以用索引
    sv[0], sv[1], sv[2]  → 线速度/力的 x, y, z
    sv[3], sv[4], sv[5]  → 角速度/力矩的 x, y, z

【具体例子】

    # 一个物体向右平移 5m/s，同时绕Z轴旋转 2rad/s
    body_velocity = wp.spatial_vector(5, 0, 0,  0, 0, 2)
    #                                 线速度     角速度

    # 向一个物体施加向上的力(10N)和绕X轴的力矩(5N·m)
    body_force = wp.spatial_vector(0, 0, 10,  5, 0, 0)
    #                              力          力矩

================================================================================
五、四种类型的完整对照关系
================================================================================

    位置在哪里？    朝哪个方向？
       vec3    +     quat     =   transform   (位姿)

    平移多快/推力？  旋转多快/力矩？
       vec3    +     vec3     =   spatial_vector  (运动/力)

    在 Newton 的 State 中：
    ──────────────────────────────────────────────
    body_q[i]  : transform        → 第i个刚体在哪+朝哪
    body_qd[i] : spatial_vector   → 第i个刚体怎么动+怎么转
    body_f[i]  : spatial_vector   → 第i个刚体受什么力+力矩

    粒子更简单（没有旋转）：
    ──────────────────────────────────────────────
    particle_q[i]  : vec3   → 粒子位置
    particle_qd[i] : vec3   → 粒子速度
    particle_f[i]  : vec3   → 粒子受力

================================================================================
六、关节系统详解
================================================================================

【关节是什么？】

    关节连接两个刚体，限制它们的相对运动。

    现实例子:
    - 门铰链 → REVOLUTE 关节（只能绕一个轴转）
    - 抽屉滑轨 → PRISMATIC 关节（只能沿一个方向滑）
    - 人的肩膀 → BALL 关节（可以任意方向转）

【parent_xform 和 child_xform 的含义】

    它们回答："关节安装在各个body的什么位置？"

    parent_xform.p = 关节在父体坐标系中的安装点
    child_xform.p  = 关节在子体坐标系中的安装点

    物理引擎的约束：这两个点在世界空间中必须始终重合！

【图解：双摆的关节 j0】

    j0 = add_joint_revolute(
        parent=-1,                    # 父体=世界（固定）
        child=link_0,                 # 子体=第一根杆
        parent_xform.p=(0, 0, 5),     # 关节安装在世界的 z=5 处
        child_xform.p=(-1, 0, 0),     # 关节安装在 link_0 的左端
    )

    (0,0,5) ← 世界中的钉子（parent_xform 指定）
        │
        │ 铰链（绕Y轴旋转）
        │
    ┌───●────────────────┐
    │x=-1  link_0中心  x=+1│   ← link_0 (半长hx=1的杆)
    └────────────────────┘
    ↑
    child_xform.p=(-1,0,0)
    "关节接在 link_0 的左端"

    结果：link_0 的左端挂在 (0,0,5)，像钟摆一样摆动

【图解：双摆的关节 j1】

    j1 = add_joint_revolute(
        parent=link_0,                # 父体=第一根杆
        child=link_1,                 # 子体=第二根杆
        parent_xform.p=(+1, 0, 0),    # 安装在 link_0 的右端
        child_xform.p=(-1, 0, 0),     # 安装在 link_1 的左端
    )

    link_0                           link_1
    ┌──────────────────●─┐       ┌─●──────────────────┐
    │ x=-1   中心   x=+1 │       │ x=-1   中心   x=+1 │
    └──────────────────┼─┘       └─┼──────────────────┘
                       │           │
                 parent_xform   child_xform
                   (+1,0,0)     (-1,0,0)
                       └───关节───┘
                    这两点始终重合!

    结果：link_1 的左端挂在 link_0 的右端 → 双摆！

【quat_identity() 在关节中的含义】

    parent_xform = transform(p=..., q=wp.quat_identity())
    q=quat_identity() 意思是："安装关节时不附加额外旋转"

    如果 q 不是 identity，就相当于关节安装时歪着装：
    q=某个旋转 → 关节坐标系被旋转了 → 旋转轴的方向跟着变

【add_articulation 和 key】

    builder.add_articulation([j0, j1], key="pendulum")

    add_articulation: 把多个关节组成一个"关节链"
        → 告诉求解器这些关节构成一个连贯的机构
        → 求解器可以更高效地处理

    key="pendulum": 给这个关节链取个名字，纯粹用于调试
        → 之后可以用 model.body_key.index("某名字") 查找编号
        → 不影响仿真结果

================================================================================
七、joint_q 和 joint_qd 的类型
================================================================================

它们是展平的 float 数组（不是 vec3，不是 transform）。

不同关节类型的坐标数量不同：

    关节类型      joint_q (坐标)              joint_qd (速度)
    ─────────────────────────────────────────────────────────
    REVOLUTE      1个float (角度θ, 弧度)      1个float (角速度ω)
    PRISMATIC     1个float (位移d, 米)        1个float (速度v)
    BALL          4个float (四元数qx,qy,qz,qw) 3个float (角速度ωx,ωy,ωz)
    FREE          7个float (x,y,z,qx,qy,qz,qw) 6个float (vx,vy,vz,ωx,ωy,ωz)
    FIXED         0个float                    0个float

    例子：双摆 (2个REVOLUTE)
    joint_q = [θ₀, θ₁]        → 2个float
    joint_qd = [ω₀, ω₁]      → 2个float

    例子：机器人 (1个FREE根 + 12个REVOLUTE)
    joint_q = [x,y,z,qx,qy,qz,qw, θ₁,...,θ₁₂]  → 19个float
    joint_qd = [vx,vy,vz,ωx,ωy,ωz, ω₁,...,ω₁₂]  → 18个float

    每个关节的坐标在数组中的起始位置:
    model.joint_q_start[i]  → 第i个关节在joint_q中的起始索引
    model.joint_qd_start[i] → 第i个关节在joint_qd中的起始索引

================================================================================
八、eval_fk（正运动学）为什么需要？
================================================================================

Newton 内部有两套描述运动状态的系统：

    ┌───────────────────┐        ┌───────────────────────────┐
    │ 关节空间 (紧凑)    │ eval_fk │  笛卡尔空间 (完整)          │
    │                   │ ──────→ │                            │
    │ joint_q = [θ₀,θ₁] │         │ body_q = [transform₀,     │
    │ "两个关节角度"     │         │           transform₁]      │
    │ (2个float就够了)  │         │ "两根杆在世界中的完整位姿"   │
    └───────────────────┘        └───────────────────────────┘

    正运动学 (Forward Kinematics) = 从关节角度 → 计算刚体位姿

    计算过程（双摆为例）：
    1. j0挂在世界的(0,0,5)，link_0连在j0上
       → 根据θ₀算出 link_0 在世界中的位置和朝向
       → 写入 body_q[0]

    2. j1挂在link_0的右端，link_1连在j1上
       → 根据θ₁和link_0的位姿，算出link_1在世界中的位置和朝向
       → 写入 body_q[1]

    为什么需要手动调用？
    ─────────────────────────────────────────────────────
    XPBD/Featherstone 等求解器直接操作 body_q（笛卡尔空间），
    所以初始化时必须调一次 eval_fk 把 joint_q 的初始值
    "翻译"成 body_q 的初始值。
    之后仿真过程中 solver.step() 自动维护 body_q。

    MuJoCo 求解器内部自己做正运动学，所以不需要手动调用。

    newton.eval_fk(model, model.joint_q, model.joint_qd, state_0)
    #               模型    关节坐标      关节速度       写入state的body_q/body_qd
"""
