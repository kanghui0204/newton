"""
Newton 知识文档 15：数值方法全解 —— 时间积分与空间离散化
============================================================

【本文件目的】
这不是一个可运行的示例，而是一份数学小白友好的知识文档。
解释 Newton 物理引擎中使用的所有数值方法，帮助你理解：

  1. 欧拉法是什么？显式/半隐式/全隐式有什么区别？
  2. 全隐式欧拉和"全隐式积分"是同一个东西吗？
  3. 牛顿-欧拉方程是什么？广义坐标（关节坐标）又是什么？
  4. 有限差分(FDM)/有限体积(FVM)/有限元(FEM)是什么？和欧拉法是一回事吗？
  5. Newton 到底用了哪些方法？代码在哪里？

================================================================================
一、物理仿真的两个核心问题
================================================================================

物理仿真要解决两个独立的问题，它们不是同一个东西：

┌─────────────────────────────────────────────────────────────────────────┐
│  问题1:【时间积分】知道"现在"，怎么算"下一刻"？                          │
│         → 欧拉法（显式/半隐式/全隐式）、Runge-Kutta 等                   │
│         → 适用于所有物理仿真（刚体、软体、流体……）                       │
│                                                                         │
│  问题2:【空间离散化】连续的物体，怎么拆成计算机能算的小块？               │
│         → 有限差分(FDM) / 有限体积(FVM) / 有限元(FEM)                    │
│         → 只有可变形物体（软体、布料）和流体才需要                        │
│         → 刚体不变形，所以不需要空间离散化                                │
└─────────────────────────────────────────────────────────────────────────┘

两者是正交的、独立的，需要组合使用。例如：
  Newton 的 SolverSemiImplicit = 半隐式欧拉（时间） + FEM（空间）

下面分别详细解释。


================================================================================
二、时间积分方法详解
================================================================================

--------------------------------------------------------------------------------
2.1 什么是"时间积分"？
--------------------------------------------------------------------------------

物理定律告诉我们力和加速度的关系（F = ma），但这是一个"连续"的描述——
真实世界中时间是连续流动的，位置在每一个瞬间都在变化。

计算机不能处理连续的东西，只能一步一步算。所以我们需要把时间切成一小段一小段：

    t=0.000s → t=0.001s → t=0.002s → t=0.003s → ...
         dt=0.001s   dt=0.001s   dt=0.001s

每一步 dt（时间步长），我们根据当前的位置、速度、力，算出下一步的位置和速度。
这个过程就叫"时间积分"。

不同的"猜法"就是不同的时间积分方法。

--------------------------------------------------------------------------------
2.2 显式欧拉法（Explicit Euler）—— 最简单但最不稳定
--------------------------------------------------------------------------------

公式：
    v_new = v + (F/m) * dt       # 用【当前力】算新速度
    x_new = x + v * dt           # 用【旧速度】算新位置  ← 注意！用的是旧的 v

特点：
  - 实现最简单（两行代码）
  - 但不稳定！如果 dt 大了或者弹簧很硬，能量会越来越大，物体飞走（"爆炸"）
  - 不保能（每步都在往系统里注入能量）

比方：
  你开车，看着当前方向盘角度，猜 1 秒后车在哪。
  如果速度快或路弯急，猜得就很离谱。

Newton 中是否使用：
  ❌ Newton 没有纯显式欧拉的求解器。因为太不稳定了，工程上基本不用。

--------------------------------------------------------------------------------
2.3 半隐式欧拉法（Semi-Implicit / Symplectic Euler）—— Newton 的主力方法
--------------------------------------------------------------------------------

公式：
    v_new = v + (F/m) * dt       # 用【当前力】算新速度（和显式一样）
    x_new = x + v_new * dt       # 用【新速度】算新位置  ← 就差这一点！

与显式的唯一区别：算位置时用新速度而不是旧速度。就改了一个变量名！
但效果天差地别——半隐式欧拉保能（长时间运行能量不会跑飞）。

源码位置: newton/_src/solvers/solver.py 第 50-56 行

    实际代码（GPU 核函数）：

        # simple semi-implicit Euler. v1 = v0 + a dt, x1 = x0 + v1 dt
        v1 = v0 + (f0 * inv_mass + world_g * wp.step(-inv_mass)) * dt   # 新速度
        x1 = x0 + v1 * dt                                                # 用新速度算新位置

    ↑ 这就是半隐式欧拉的全部！就两行。
      关键是 x1 = x0 + v1 * dt 而不是 x1 = x0 + v0 * dt。

特点：
  - 非常简单，几乎不比显式多一点计算量
  - 能量守恒好（symplectic = "保辛"，数学上保证能量不漂移）
  - 但不是无条件稳定——如果弹簧太硬或 dt 太大，还是会炸
  - 需要比较小的 dt（通常 0.001s 左右）

Newton 中的使用：
  ✅ SolverSemiImplicit — 通用半隐式求解器
     源码: newton/_src/solvers/semi_implicit/solver_semi_implicit.py
     使用方式：
       1. 先算所有力（弹簧力、碰撞力、关节力、重力……）累积到 state.body_f / particle_f
       2. 调用 integrate_particles() 和 integrate_bodies()
       3. 两个函数内部就是上面那两行半隐式欧拉

  ✅ SolverFeatherstone — 在关节坐标下也用半隐式欧拉（后面第三节详解）
     源码: newton/_src/solvers/featherstone/solver_featherstone.py

比方：
  开车时先踩刹车/油门改变速度，然后用【改变后的速度】算 1 秒后在哪。
  比显式的"看当前速度瞎猜"靠谱多了。

--------------------------------------------------------------------------------
2.4 全隐式欧拉法（Implicit Euler）—— 最稳定但计算量大
--------------------------------------------------------------------------------

公式：
    v_new = v + (F(x_new)/m) * dt     # 力取决于【新位置】！
    x_new = x + v_new * dt

问题来了：要算新速度 v_new，需要知道新位置 x_new 处的力 F(x_new)，
但新位置 x_new 又取决于新速度 v_new。这是一个"鸡生蛋、蛋生鸡"的问题！

解决方法：把它变成一个方程组，用迭代法求解：
    (M/dt² + H(x)) · dx = (M/dt²) · (x_inertia - x) + f_int(x)

    其中：
    - M = 质量矩阵
    - H(x) = Hessian 矩阵（力对位置的导数，描述"刚度"）
    - dx = 位置修正量
    - f_int(x) = 内力（弹性力）

    这个方程需要用线性求解器（如 PCG、Cholesky）来解，计算量大得多。

源码位置: newton/_src/solvers/style3d/solver_style3d.py 第 54-68 行

    Style3D 求解器的注释写得很清楚：

        Implicit-Euler method solves the following non-linear equation:

        (M / dt² + H(x)) · dx = (M / dt²) · (x_prev + v_prev·dt - x) + f_int(x)

特点：
  - 无条件稳定！dt 很大也不会爆炸（不过精度会下降）
  - 计算量大（每步要解线性方程组，通常用 PCG 迭代）
  - 适合需要大 dt 的场景（比如布料仿真想要 dt=0.01s 而不是 0.001s）

Newton 中的使用：
  ✅ SolverStyle3D — 布料求解器（投影动力学 + 隐式欧拉）
     源码: newton/_src/solvers/style3d/solver_style3d.py
     方程就是上面的 (M/dt² + H) · dx = rhs

比方：
  你要求车 1 秒后必须到某个位置，反过来算方向盘应该怎么打。
  最精确但最费脑。

--------------------------------------------------------------------------------
2.5 "全隐式积分"和"全隐式欧拉"的区别是什么？
--------------------------------------------------------------------------------

很多人（包括写文档的人）经常混用这两个词，这里澄清一下：

【全隐式欧拉 (Implicit Euler)】
  - 特指一种具体的时间积分公式：
      v_new = v + a(x_new) * dt
      x_new = x + v_new * dt
  - 是一阶方法（精度 O(dt)）
  - Newton 中：SolverStyle3D 用的就是这个

【全隐式积分 (Implicit Integration)】
  - 是一个更宽泛的类别名称，泛指所有"需要求解方程组"的时间积分方法
  - 全隐式欧拉是其中一种
  - 还包括：隐式中点法、Newmark-beta、BDF 方法等
  - Newton 中：SolverImplicitMPM 用的也是隐式积分，但不完全是标准的隐式欧拉

所以关系是：
  ┌─────────────────────────────────┐
  │      隐式积分（大类）             │
  │  ┌───────────────────────┐      │
  │  │  隐式欧拉（一种具体的） │      │
  │  └───────────────────────┘      │
  │  ┌───────────────────────┐      │
  │  │  隐式中点法（另一种）    │      │
  │  └───────────────────────┘      │
  │  ┌───────────────────────┐      │
  │  │  Newmark-beta（又一种） │      │
  │  └───────────────────────┘      │
  │       ...                       │
  └─────────────────────────────────┘

在 Newton 里：
  - SolverStyle3D：明确说了 "Implicit-Euler method" → 全隐式欧拉
  - SolverImplicitMPM：说的是 "Implicit MPM solver" → 隐式积分（是一种
    隐式方法，但 MPM 有自己的网格-粒子转换步骤，不是纯粹的隐式欧拉）

实际上，在 Newton 的语境下你可以把它们当成差不多的东西——都是
"需要解方程组、无条件稳定、计算量比半隐式大"的方法。

--------------------------------------------------------------------------------
2.6 位置级方法（XPBD、VBD）—— 一种不同思路
--------------------------------------------------------------------------------

除了上面基于力的欧拉法，还有一类完全不同的思路：直接操作位置。

【XPBD (eXtended Position-Based Dynamics)】

思路：
  1. 先用半隐式欧拉做一个"粗略预测"（预测位置 x_pred）
  2. 然后检查所有约束是否被违反（关节脱开了？穿透了？弹簧太长了？）
  3. 用位置投影把违反的约束修正回来（直接移动粒子位置）
  4. 最后从修正后的位置反算实际速度

源码位置: newton/_src/solvers/xpbd/solver_xpbd.py

特点：
  - 非常稳定（位置投影不会爆炸）
  - 实现简单
  - 但物理精度不如力级别的方法（弹簧刚度不精确）
  - Newton 的默认刚体求解器

【VBD (Vertex Block Descent)】

思路：
  1. 先做前向积分预测位置
  2. 然后逐顶点优化能量函数（类似牛顿法迭代）
  3. 每个顶点独立求解一个小的 3×3 线性系统

源码位置: newton/_src/solvers/vbd/solver_vbd.py

特点：
  - 比 XPBD 精确（用了 Hessian 信息）
  - 比全隐式欧拉快（不用全局线性系统）
  - 适合布料和软体

--------------------------------------------------------------------------------
2.7 Newton 所有求解器的时间积分方法总结
--------------------------------------------------------------------------------

┌────────────────────┬──────────────────────────────┬──────────────────────────────────────────────────────┐
│ 求解器              │ 时间积分方法                  │ 源码位置                                              │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverSemiImplicit  │ 半隐式欧拉（Symplectic Euler）│ newton/_src/solvers/semi_implicit/                    │
│                     │ v1=v0+a*dt, x1=x0+v1*dt     │   solver_semi_implicit.py                            │
│                     │                              │ 积分核: newton/_src/solvers/solver.py 第 50-56 行      │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverFeatherstone  │ 半隐式欧拉（广义坐标下）      │ newton/_src/solvers/featherstone/                     │
│                     │ 在关节空间做半隐式积分         │   solver_featherstone.py                             │
│                     │                              │ 积分核: featherstone/kernels.py 第 1347 行             │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverXPBD          │ 位置级方法                    │ newton/_src/solvers/xpbd/solver_xpbd.py               │
│                     │ 半隐式预测 + 约束位置投影      │ 约束核: xpbd/kernels.py                               │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverVBD           │ 前向积分 + 逐顶点牛顿迭代     │ newton/_src/solvers/vbd/solver_vbd.py                 │
│                     │ （类似隐式方法的精度）          │ 核函数: vbd/particle_vbd_kernels.py                   │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverStyle3D       │ 全隐式欧拉（Implicit Euler）  │ newton/_src/solvers/style3d/solver_style3d.py         │
│                     │ (M/dt²+H)·dx = rhs           │ 线性求解: style3d/linear_solver.py (PCG)              │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverImplicitMPM   │ 隐式积分                      │ newton/_src/solvers/implicit_mpm/                     │
│                     │ 粒子-网格隐式耦合              │   solver_implicit_mpm.py                             │
├────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────┤
│ SolverMuJoCo        │ MuJoCo 内部实现                │ newton/_src/solvers/mujoco/solver_mujoco.py           │
│                     │ （半隐式变种 + 接触处理）       │ 调用 mujoco-warp 库                                  │
└────────────────────┴──────────────────────────────┴──────────────────────────────────────────────────────┘


================================================================================
三、牛顿-欧拉方程与关节坐标
================================================================================

这部分解释刚体仿真中两种不同的描述方式，以及 Newton 中的具体使用。

注意：这里的"牛顿-欧拉方程"中的"欧拉"是指 欧拉旋转方程（描述刚体转动），
和上面的"欧拉时间积分法"是两个不同的东西！只是碰巧都叫欧拉（同一个数学家）。

--------------------------------------------------------------------------------
3.1 牛顿-欧拉方程（Newton-Euler Equations）—— 描述刚体运动的基本方程
--------------------------------------------------------------------------------

每一个刚体的运动可以分成两部分：平移 + 旋转。

【平移（牛顿第二定律）】
    F = m * a
    即：合力 = 质量 × 加速度
    → 告诉你质心怎么移动

【旋转（欧拉旋转方程）】
    τ = I * α + ω × (I * ω)
    即：合力矩 = 惯性张量 × 角加速度 + 陀螺效应
    → 告诉你物体怎么转

    其中：
    - τ (tau)：合力矩（扭矩）
    - I：惯性张量（3×3矩阵，描述物体质量分布对旋转的"抵抗"）
    - α：角加速度
    - ω：角速度
    - ω × (I * ω)：陀螺效应（旋转物体会产生的额外力矩，陀螺就是靠这个原理不倒的）

源码位置: newton/_src/solvers/solver.py 第 62-106 行 (integrate_rigid_body 函数)

    # 平移部分（牛顿第二定律）
    v1 = v0 + (f0 * inv_mass + gravity * wp.nonzero(inv_mass)) * dt   # F=ma → a=F/m
    x1 = x_com + v1 * dt                                              # 新位置

    # 旋转部分（欧拉旋转方程，在体坐标系下计算）
    wb = wp.quat_rotate_inv(r0, w0)                          # 角速度转到体坐标系
    tb = wp.quat_rotate_inv(r0, t0) - wp.cross(wb, inertia * wb)  # 力矩 - 陀螺效应
    w1 = wp.quat_rotate(r0, wb + inv_inertia * tb * dt)      # 新角速度
    r1 = wp.normalize(r0 + wp.quat(w1, 0.0) * r0 * 0.5 * dt)  # 新旋转（四元数积分）

    ↑ 这就是牛顿-欧拉方程的完整实现！
      注意 wp.cross(wb, inertia * wb) 就是陀螺效应项 ω × (I * ω)。

这种方法叫"最大坐标法"（Maximal Coordinates）——每个刚体独立描述，
用 7 个变量：位置(3) + 四元数(4)。

Newton 中使用这种方法的求解器：
  ✅ SolverSemiImplicit
  ✅ SolverXPBD

--------------------------------------------------------------------------------
3.2 广义坐标 / 关节坐标（Generalized / Joint Coordinates）—— 机器人的描述方式
--------------------------------------------------------------------------------

对于机器人这种由关节连接的多刚体系统，有一个更聪明的描述方式：
不描述每个刚体在哪里，而是描述每个关节转了多少度。

比方：
  人的手臂有 肩关节(3轴) + 肘关节(1轴) + 腕关节(2轴) = 6个自由度
  最大坐标法：描述 上臂位姿(7) + 前臂位姿(7) + 手掌位姿(7) = 21 个变量
                   但实际只有 6 个自由度！15 个变量是冗余的！
  关节坐标法：只用 6 个关节角度 [θ_shoulder_x, θ_shoulder_y, θ_shoulder_z,
                                   θ_elbow, θ_wrist_x, θ_wrist_y]

关节坐标法的好处：
  - 没有冗余变量（不需要约束投影来保持关节连接）
  - 关节不会"脱开"（最大坐标法中，数值误差可能导致关节分离）
  - 自然地保持运动学约束

关节坐标法的核心算法是 Featherstone 算法：

【Featherstone 复合刚体算法 (CRBA)】
  输入：关节角度 joint_q，关节角速度 joint_qd，外力
  过程：
    1. 正向遍历：从根到叶，计算每个关节的速度和科氏力（Forward Pass）
    2. 反向遍历：从叶到根，累积惯性和力（Backward Pass）
    3. 求解：M * joint_qdd = tau（质量矩阵 × 关节加速度 = 广义力）
    4. 积分：joint_qd_new = joint_qd + joint_qdd * dt
             joint_q_new = joint_q + joint_qd_new * dt

  这其中第1+2步又叫 RNEA（递推牛顿-欧拉算法），本质上是高效地
  把牛顿-欧拉方程沿关节树递推计算，避免了组装大矩阵。

源码位置: newton/_src/solvers/featherstone/kernels.py

    # 第 781 行：递推牛顿-欧拉算法（RNEA）
    # Inverse dynamics via Recursive Newton-Euler algorithm (Featherstone Table 5.1)
    @wp.kernel
    def eval_rigid_id(...)

    # 第 1347 行：关节坐标积分（半隐式欧拉，在关节空间进行）
    @wp.kernel
    def integrate_generalized_joints(...)

Newton 中使用关节坐标的求解器：
  ✅ SolverFeatherstone — 用 CRBA + RNEA 算法
     源码: newton/_src/solvers/featherstone/solver_featherstone.py
     特点："A semi-implicit integrator using symplectic Euler that operates
            on reduced (generalized) coordinates to simulate articulated
            rigid body dynamics based on Featherstone's CRBA."

  ✅ SolverMuJoCo — 也使用关节坐标，但通过 mujoco-warp 库实现
     源码: newton/_src/solvers/mujoco/solver_mujoco.py

--------------------------------------------------------------------------------
3.3 两种方法的对比
--------------------------------------------------------------------------------

┌──────────────────────────────┬───────────────────────────────────┐
│  最大坐标法（Maximal）         │  关节坐标法（Generalized）         │
├──────────────────────────────┼───────────────────────────────────┤
│  每个刚体：位置(3) + 旋转(4)  │  每个关节：角度(1~6)              │
│  变量多，有冗余                │  变量少，无冗余                    │
│  需要约束力保持关节连接         │  关节自动保持连接                  │
│  关节可能"脱开"（数值误差）    │  不会脱开                         │
│  适合自由刚体 + 简单关节       │  适合复杂关节链（机器人、人形）     │
│  碰撞处理更直接                │  碰撞处理需要转换坐标              │
│                               │                                   │
│  Newton: SolverSemiImplicit   │  Newton: SolverFeatherstone        │
│  Newton: SolverXPBD           │  Newton: SolverMuJoCo              │
└──────────────────────────────┴───────────────────────────────────┘

两种方法都用半隐式欧拉做时间积分，区别只在"用什么坐标描述系统"。

正运动学(FK)和逆运动学(IK)就是在这两个坐标之间转换：
  FK: 关节角度 → 刚体位姿（joint_q → body_q）
  IK: 目标位姿 → 关节角度（body_q → joint_q）


================================================================================
四、空间离散化方法详解
================================================================================

空间离散化只在可变形物体（布料、软体）和连续介质（流体）中需要。
刚体不变形，所以不需要空间离散化。

--------------------------------------------------------------------------------
4.1 有限差分法 FDM（Finite Difference Method）—— "网格点上近似导数"
--------------------------------------------------------------------------------

核心思想：
  在规则的网格上（像 Excel 表格），用相邻点的值差来近似导数。

    ∂f/∂x ≈ (f[i+1] - f[i-1]) / (2*Δx)

示意：
    ●───●───●───●───●
    │   │   │   │   │
    ●───●───●───●───●       ← 规则的方形网格
    │   │   │   │   │
    ●───●───●───●───●

    每个 ● 是一个网格点，存储物理量（温度、速度、压力等）
    用相邻点的差来近似梯度、拉普拉斯算子等

优点：实现最简单
缺点：只适合规则几何区域（长方形），处理不了复杂形状

典型应用：流体仿真（CFD）、热传导、图像处理（不适合固体力学）

Newton 中：❌ 没有使用 FDM

--------------------------------------------------------------------------------
4.2 有限体积法 FVM（Finite Volume Method）—— "格子间的通量"
--------------------------------------------------------------------------------

核心思想：
  把空间划分成小格子（控制体积），追踪每个格子里的守恒量（质量、动量、能量），
  计算格子之间的"通量"（流入流出）。

示意：
    ┌───────┬───────┬───────┐
    │       │       │       │
    │  格子1 │←通量→│ 格子2  │     ← 计算格子间的流量
    │       │       │       │
    └───────┴───────┴───────┘

    格子1 的质量变化 = 流入的质量 - 流出的质量（天然守恒！）

优点：天然守恒（质量/能量不会凭空消失），适合可压缩/不可压缩流体
缺点：对固体力学不太方便

典型应用：CFD（OpenFOAM、Fluent 等流体仿真软件的核心方法）

Newton 中：❌ 没有使用 FVM

--------------------------------------------------------------------------------
4.3 有限元法 FEM（Finite Element Method）—— Newton 处理可变形体的核心方法
--------------------------------------------------------------------------------

核心思想：
  把物体拆成很多小元素（2D 用三角形，3D 用四面体），
  在每个小元素内部用简单的函数（通常是线性的）来近似变形，
  然后把所有元素的贡献"组装"起来，得到整个物体的行为。

示意（2D 布料 → 三角形元素）：

    顶点0 ────── 顶点1
      \  三角形  /
       \  元素  /
        \      /
         \    /
          \  /
         顶点2

    每个三角形内部假设变形是均匀的（线性近似）
    从 3 个顶点的位置可以算出"变形梯度" F
    然后用材料模型（如 Neo-Hookean）从 F 算出应力和力

示意（3D 软体 → 四面体元素）：

    4 个顶点构成一个四面体
    从 4 个顶点的位置可以算出 3×3 的变形梯度 F
    然后用 3D 材料模型算出体积变形的力

FEM 的核心计算步骤：
  1. 变形梯度: F = Ds * Dm_inv
     - Ds = 当前形状矩阵（用当前顶点位置构造）
     - Dm_inv = 原始形状矩阵的逆（只在初始化时计算一次）
     - F 表示"这个元素相对初始形状变形了多少"

  2. 材料模型: P = f(F)
     - Neo-Hookean: P = μ*(F - F^{-T}) + λ*ln(J)*F^{-T}
     - 其中 μ, λ 是材料参数（拉梅常数），J = det(F) 是体积变化率
     - P 是第一 Piola-Kirchhoff 应力张量

  3. 节点力: f_i = -V₀ * P * ∂F/∂x_i
     - V₀ = 元素原始体积
     - ∂F/∂x_i = 变形梯度对顶点 i 的导数

优点：能处理任意复杂几何形状，有坚实的数学理论
缺点：实现较复杂，需要网格生成

Newton 中：✅ 大量使用 FEM！

--------------------------------------------------------------------------------
4.4 Newton 中 FEM 的具体实现
--------------------------------------------------------------------------------

【三角形 FEM（2D，用于布料）】

源码位置: newton/_src/solvers/semi_implicit/kernels_particle.py
         函数: eval_triangle() 第 69-184 行

    计算流程：
    1. 取三角形的 3 个顶点位置 x0, x1, x2
    2. 计算边向量 x10 = x1-x0, x20 = x2-x0
    3. 构造当前形状矩阵 Xs = [x10, x20]（2列向量）
    4. 变形梯度 F = Xs * Xm_inv（Xm_inv 是原始形状矩阵的逆，预计算好的）
    5. Neo-Hookean 材料模型 → 算出应力 P
    6. 应力 → 节点力 → 累加到 particle_f

    这段代码中的关键行：
        # 变形梯度（第 114-116 行附近）
        F = Xs * Xm_inv

        # Neo-Hookean 应力（第 127 行附近）
        P1 = F1 * k_mu + dFdt1 * k_damp   # 弹性 + 阻尼

【四面体 FEM（3D，用于软体）】

源码位置: newton/_src/solvers/semi_implicit/kernels_particle.py
         函数: eval_tetrahedra() 第 262-437 行

    计算流程：
    1. 取四面体的 4 个顶点位置 x0, x1, x2, x3
    2. 计算边向量 x10 = x1-x0, x20 = x2-x0, x30 = x3-x0
    3. 构造当前形状矩阵 Ds = [x10, x20, x30]（3×3矩阵）
    4. 变形梯度 F = Ds * Dm_inv
    5. Neo-Hookean (Smith et al. 2018 稳定版) → 应力 P
    6. 体积约束 (J - alpha) → 保持体积
    7. 应力 → 节点力

    关键行：
        # 变形梯度（第 316 行附近）
        Ds = wp.matrix_from_cols(x10, x20, x30)
        F = Ds * Dm    # Dm 这里就是 Dm_inv

        # Neo-Hookean（第 324-329 行附近）
        Ic = trace(F^T * F)    # 第一不变量
        P = mu * (F - ...) + lambda * (J - alpha) * cofactor(F)

【XPBD 中的四面体约束（位置级 FEM）】

源码位置: newton/_src/solvers/xpbd/kernels.py
         函数: solve_tetrahedra() 第 462-568 行, solve_tetrahedra2() 第 633-775 行

    和上面力级别 FEM 的区别：
    - 力级别：算出力 F → 加到速度 v → 更新位置 x（间接影响位置）
    - 位置级(XPBD)：算出约束违反量 C → 直接修正位置 x（跳过力和速度）

    XPBD 四面体约束：
        C_stretch = trace(F^T*F) - 3   → 拉伸约束（应该等于0）
        C_volume = det(F) - 1          → 体积约束（应该等于0）
        Δx = -C / (∂C/∂x)^2           → 位置修正量

【VBD 中的四面体 FEM（带 Hessian 的隐式 FEM）】

源码位置: newton/_src/solvers/vbd/particle_vbd_kernels.py
         函数: evaluate_volumetric_neo_hookean_force_and_hessian() 第 347-474 行

    除了计算力（像 semi_implicit 一样），还计算 Hessian 矩阵（力对位置的二阶导数）。
    Hessian 用于 VBD 的牛顿法迭代，使收敛更快。

【MPM 中的 FEM（粒子转网格后做 FEM）】

源码位置: newton/_src/solvers/implicit_mpm/solver_implicit_mpm.py

    MPM 的特殊之处：粒子不直接用 FEM，而是：
    1. 把粒子的物理量"涂"到背景网格上（Particle-to-Grid, P2G）
    2. 在网格上做 FEM 求解（用 Warp FEM 库：@fem.integrand）
    3. 把网格上的结果"插值"回粒子（Grid-to-Particle, G2P）

    使用 warp.fem 模块提供的有限元积分框架。

--------------------------------------------------------------------------------
4.5 FDM vs FVM vs FEM 对比总结
--------------------------------------------------------------------------------

┌────────────┬─────────────────┬─────────────────┬─────────────────────┐
│            │ FDM (有限差分)   │ FVM (有限体积)   │ FEM (有限元)         │
├────────────┼─────────────────┼─────────────────┼─────────────────────┤
│ 核心思想    │ 近似导数         │ 守恒通量         │ 元素内函数近似       │
│ 网格类型    │ 规则网格         │ 任意多面体       │ 三角/四面体          │
│ 擅长领域    │ 流体、热传导     │ 流体（CFD）      │ 固体力学、结构       │
│ 守恒性      │ 不天然守恒       │ 天然守恒         │ 通过弱形式保证       │
│ 复杂几何    │ 差               │ 好               │ 最好                │
│ 实现难度    │ 最简单           │ 中等             │ 最复杂              │
│ Newton 使用 │ ❌ 未使用        │ ❌ 未使用        │ ✅ 布料+软体+MPM    │
│ 典型软件    │ 简单 CFD         │ OpenFOAM/Fluent │ ABAQUS/ANSYS        │
└────────────┴─────────────────┴─────────────────┴─────────────────────┘

Newton 作为物理引擎主要面向固体力学（刚体、布料、软体），所以只用 FEM。
如果你做流体仿真，会接触 FDM 和 FVM；但在 Newton 里不需要关心它们。


================================================================================
五、完整全景图：时间 × 空间 × 求解器
================================================================================

┌────────────────────┬───────────────────┬──────────────────┬──────────────────────────┐
│ 求解器              │ 处理对象           │ 时间积分          │ 空间离散化                │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverSemiImplicit  │ 刚体              │ 半隐式欧拉        │ 不需要（刚体不变形）       │
│                     │ 布料(三角形FEM)    │ 半隐式欧拉        │ FEM: 三角形 Neo-Hookean   │
│                     │ 软体(四面体FEM)    │ 半隐式欧拉        │ FEM: 四面体 Neo-Hookean   │
│                     │ 弹簧              │ 半隐式欧拉        │ 弹簧-质点（不算 FEM）     │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverFeatherstone  │ 刚体(关节链)       │ 半隐式欧拉        │ 不需要                    │
│                     │ 布料/软体          │ 复用SemiImplicit  │ 同上                      │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverXPBD          │ 刚体              │ 位置投影          │ 不需要                    │
│                     │ 布料/软体          │ 位置投影          │ FEM: 四面体约束           │
│                     │ 弹簧              │ 位置投影          │ 弹簧约束                  │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverVBD           │ 布料(三角形)       │ VBD 迭代(隐式级)  │ FEM: StVK + Hessian      │
│                     │ 软体(四面体)       │ VBD 迭代(隐式级)  │ FEM: Neo-Hookean+Hessian │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverStyle3D       │ 布料              │ 全隐式欧拉        │ FEM: StVK (各向异性)     │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverImplicitMPM   │ 颗粒/流体/沙      │ 隐式积分          │ MPM (粒子+FEM网格)       │
├────────────────────┼───────────────────┼──────────────────┼──────────────────────────┤
│ SolverMuJoCo        │ 刚体(关节链)       │ MuJoCo 内部       │ 不需要                    │
└────────────────────┴───────────────────┴──────────────────┴──────────────────────────┘


================================================================================
六、一句话总结
================================================================================

  "欧拉法管时间推进，FEM 管空间切割，牛顿-欧拉方程管刚体运动。"

  - 时间积分方法（显式/半隐式/隐式）决定仿真的 稳定性 和 计算量
  - 空间离散化方法（FDM/FVM/FEM）决定可变形物体的 形状描述 和 力的计算
  - 牛顿-欧拉方程/Featherstone 决定刚体的 运动描述 方式
  - 三者正交，组合使用。Newton 主要用 半隐式欧拉 + FEM + 牛顿-欧拉方程。
"""
